////////////////////////////////////////////////////////////////////////////////////////////////
//
//  MMD Extended Shader (MES40) ver 1.11
//
//  For credits, go to https://github.com/KH40-khoast40/MES40
//
////////////////////////////////////////////////////////////////////////////////////////////////

// ■ ExcellentShadowシステム　ここから↓

float X_SHADOWPOWER = 1.0;   //アクセサリ影濃さ
float PMD_SHADOWPOWER = 0.2; //モデル影濃さ


//スクリーンシャドウマップ取得
shared texture2D ScreenShadowMapProcessed : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0,1.0};
    int MipLevels = 1;
    string Format = "D3DFMT_R16F";
>;
sampler2D ScreenShadowMapProcessedSamp = sampler_state {
    texture = <ScreenShadowMapProcessed>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP; AddressV = CLAMP;
};

//SSAOマップ取得
shared texture2D ExShadowSSAOMapOut : RENDERCOLORTARGET <
    float2 ViewPortRatio = {1.0,1.0};
    int MipLevels = 1;
    string Format = "R16F";
>;

sampler2D ExShadowSSAOMapSamp = sampler_state {
    texture = <ExShadowSSAOMapOut>;
    MinFilter = LINEAR; MagFilter = LINEAR; MipFilter = NONE;
    AddressU  = CLAMP; AddressV = CLAMP;
};

// スクリーンサイズ
float2 ES_ViewportSize : VIEWPORTPIXELSIZE;
static float2 ES_ViewportOffset = (float2(0.5,0.5)/ES_ViewportSize);

bool Exist_ExcellentShadow : CONTROLOBJECT < string name = "ExcellentShadow.x"; >;
bool Exist_ExShadowSSAO : CONTROLOBJECT < string name = "ExShadowSSAO.x"; >;
float ShadowRate : CONTROLOBJECT < string name = "ExcellentShadow.x"; string item = "Tr"; >;
float3   ES_CameraPos1      : POSITION  < string Object = "Camera"; >;
float es_size0 : CONTROLOBJECT < string name = "ExcellentShadow.x"; string item = "Si"; >;
float4x4 es_mat1 : CONTROLOBJECT < string name = "ExcellentShadow.x"; >;

static float3 es_move1 = float3(es_mat1._41, es_mat1._42, es_mat1._43 );
static float CameraDistance1 = length(ES_CameraPos1 - es_move1); //カメラとシャドウ中心の距離

// ■ ExcellentShadowシステム　ここまで↑
////////////////////////////////////////////////////////////////////////////////////////////////

float4 EgColor; //MMD材質モーフ後カラー取得用
float4 SpcColor; //MMD材質モーフ後カラー取得用

////////////////////////////////////////////////////////////////////////////////////////////////
// パラメータ宣言

// 座法変換行列
float4x4 WorldViewProjMatrix      : WORLDVIEWPROJECTION;
float4x4 WorldMatrix              : WORLD;
float4x4 ViewMatrix               : VIEW;
float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float3   LightDirection    : DIRECTION < string Object = "Light"; >;
float3   CameraPosition    : POSITION  < string Object = "Camera"; >;

// マテリアル色
float4   MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float3   MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float3   MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float3   MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float    SpecularPower     : SPECULARPOWER < string Object = "Geometry"; >;
float3   MaterialToon      : TOONCOLOR;
float4   EdgeColor         : EDGECOLOR;
float4   GroundShadowColor : GROUNDSHADOWCOLOR;
// ライト色
float3   LightDiffuse      : DIFFUSE   < string Object = "Light"; >;
float3   LightAmbient      : AMBIENT   < string Object = "Light"; >;
float3   LightSpecular     : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor  = MaterialDiffuse  * float4(LightDiffuse, 1.0f);
static float3 AmbientColor  = MaterialAmbient  * LightAmbient + MaterialEmmisive;
static float3 SpecularColor = MaterialSpecular * LightSpecular;

// テクスチャ材質モーフ値
float4   TextureAddValue   : ADDINGTEXTURE;
float4   TextureMulValue   : MULTIPLYINGTEXTURE;
float4   SphereAddValue    : ADDINGSPHERETEXTURE;
float4   SphereMulValue    : MULTIPLYINGSPHERETEXTURE;

bool	 use_subtexture;    // サブテクスチャフラグ

bool     parthf;   // パースペクティブフラグ
bool     transp;   // 半透明フラグ
bool	 spadd;    // スフィアマップ加算合成フラグ
#define SKII1    1500
#define SKII2    8000

//////////////////////////////////////////
#ifndef Toon_Intensity
	#define Toon_Intensity 1
#endif
//////////////////////////////////////////
#ifndef Toon_Brightness
	#define Toon_Brightness 1
#endif
//////////////////////////////////////////
#ifndef Toon_Gradient
	#define Toon_Gradient 3
#endif
//////////////////////////////////////////


//////////////////////////////////////////
#ifndef Spa_CubeMap_Intensity
	#define Spa_CubeMap_Intensity 1
#endif
//////////////////////////////////////////
#ifndef Spa_CubeMap_Saturation
	#define Spa_CubeMap_Saturation 1
#endif
//////////////////////////////////////////


//////////////////////////////////////////
#ifndef SpecularLight_Intensity
	#define SpecularLight_Intensity 1
#endif
//////////////////////////////////////////
#ifndef SpecularLight_Focus
	#define SpecularLight_Focus SpecularPower
#endif
//////////////////////////////////////////
#ifndef SpecularLight_Affected_By_LightDirection
	#define SpecularLight_Affected_By_LightDirection 1
#endif
//////////////////////////////////////////

// オブジェクトのテクスチャ
#ifndef AnimatedTexture
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#ifdef AnimatedTexture
texture ObjectTexture: ANIMATEDTEXTURE 
<
	string ResourceName = AnimatedTexture;
>;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

// スフィアマップのテクスチャ
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
    texture = <ObjectSphereMap>;
    MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};

// トゥーンマップのテクスチャ
texture ObjectToonTexture: MATERIALTOONTEXTURE;
sampler ObjToonSampler = sampler_state {
    texture = <ObjectToonTexture>;
    MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = CLAMP;
	ADDRESSV  = CLAMP;
	MAXANISOTROPY = 16;
};

#ifdef NormalMapTexture
//Normal Map
texture2D NormalMap <
	string ResourceName = NormalMapTexture;
	int MipLevels = 0;
>;
sampler2D NormalMapSamp = sampler_state {
	texture = <NormalMap>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};

float3x3 compute_tangent_frame(float3 Normal, float3 View, float2 UV)
{
  float3 dp1 = ddx(View);
  float3 dp2 = ddy(View);
  float2 duv1 = ddx(UV);
  float2 duv2 = ddy(UV);

  float3x3 M = float3x3(dp1, dp2, cross(dp1, dp2));
  float2x3 inverseM = float2x3(cross(M[1], M[2]), cross(M[2], M[0]));
  float3 Tangent = mul(float2(duv1.x, duv2.x), inverseM);
  float3 Binormal = mul(float2(duv1.y, duv2.y), inverseM);

  return float3x3(normalize(Tangent), normalize(Binormal), Normal);
}
#endif

#ifdef SpecularMapTexture
//Specular Map
texture2D SpecularMap <
	string ResourceName = SpecularMapTexture;
	int MipLevels = 0;
>;
sampler2D SpecularMapSamp = sampler_state {
	texture = <SpecularMap>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

#ifdef CubeMapTexture
//Cube Map
textureCUBE CubeMap
<
	string ResourceName = CubeMapTexture;
>;
sampler CubeMapSamp = sampler_state
{
    Texture = <CubeMap>;
    MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = CLAMP;
	ADDRESSV  = CLAMP;
	MAXANISOTROPY = 16;
};
#endif

#ifdef SubMapTexture
//Sub Map
texture2D SubMap <
	string ResourceName = SubMapTexture;
	int MipLevels = 0;
>;
sampler2D SubMapSamp = sampler_state {
	texture = <SubMap>;
	MINFILTER = ANISOTROPIC;
	MAGFILTER = ANISOTROPIC;
	MIPFILTER = ANISOTROPIC;
	ADDRESSU  = WRAP;
	ADDRESSV  = WRAP;
	MAXANISOTROPY = 16;
};
#endif

////////////////////////////////////////////////////////////////////////////////////////////////
// 輪郭描画

// 頂点シェーダ
float4 ColorRender_VS(float4 Pos : POSITION) : POSITION 
{
    // カメラ視点のワールドビュー射影変換
    return mul( Pos, WorldViewProjMatrix );
}

// ピクセルシェーダ
float4 ColorRender_PS() : COLOR
{
    // 輪郭色で塗りつぶし
    return EdgeColor;
}

// 輪郭描画用テクニック
technique EdgeTec < string MMDPass = "edge"; > {
    pass DrawEdge {
        VertexShader = compile vs_2_0 ColorRender_VS();
        PixelShader  = compile ps_2_0 ColorRender_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// 影（非セルフシャドウ）描画

// 頂点シェーダ
float4 Shadow_VS(float4 Pos : POSITION) : POSITION
{
    // カメラ視点のワールドビュー射影変換
    return mul( Pos, WorldViewProjMatrix );
}

// ピクセルシェーダ
float4 Shadow_PS() : COLOR
{
    // 地面影色で塗りつぶし
    return GroundShadowColor;
}

// 影描画用テクニック
technique ShadowTec < string MMDPass = "shadow"; > {
    pass DrawShadow {
        VertexShader = compile vs_2_0 Shadow_VS();
        PixelShader  = compile ps_2_0 Shadow_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウOFF）

struct VS_OUTPUT {
    float4 Pos        : POSITION;    // 射影変換座標
    float2 Tex        : TEXCOORD1;   // テクスチャ
    float3 Normal     : TEXCOORD2;   // 法線
    float3 Eye        : TEXCOORD3;   // カメラとの相対位置
    float2 SpTex      : TEXCOORD4;	 // スフィアマップテクスチャ座標
    float4 Color      : COLOR0;      // ディフューズ色
    float3 Specular   : COLOR1;      // スペキュラ色
};

// 頂点シェーダ
VS_OUTPUT Basic_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, float2 Tex2 : TEXCOORD1, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
    VS_OUTPUT Out = (VS_OUTPUT)0;
    
    // カメラ視点のワールドビュー射影変換
    Out.Pos = mul( Pos, WorldViewProjMatrix );
    
    // カメラとの相対位置
    Out.Eye = CameraPosition - mul( Pos, WorldMatrix );
    // 頂点法線
    Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );
    
    // ディフューズ色＋アンビエント色 計算
    Out.Color.rgb = AmbientColor;
    if ( !useToon ) {
        Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * DiffuseColor.rgb;
    }
    Out.Color.a = DiffuseColor.a;
    Out.Color = saturate( Out.Color );
    
    // テクスチャ座標
    Out.Tex = Tex;
    
    if ( useSphereMap ) {
		if ( use_subtexture ) {
			// PMXサブテクスチャ座標
			Out.SpTex = Tex2;
	    } else {
	        // スフィアマップテクスチャ座標
	        float2 NormalWV = mul( Out.Normal, (float3x3)ViewMatrix );
	        Out.SpTex.x = NormalWV.x * 0.5f + 0.5f;
	        Out.SpTex.y = NormalWV.y * -0.5f + 0.5f;
	    }
    }
    
    // スペキュラ色計算
    float3 HalfVector = normalize( normalize(Out.Eye) + -LightDirection );
    Out.Specular = pow( max(0,dot( HalfVector, Out.Normal )), SpecularLight_Focus ) * SpecularColor;
    
    return Out;
}

// ピクセルシェーダ
float4 Basic_PS(VS_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR0
{
	//////////////////////Specular Map related values//////////////////////////////////////
	#ifdef SpecularMapTexture
	float4 SpecularLevel = tex2D(SpecularMapSamp, IN.Tex);
	
	#else
	float4 SpecularLevel = float4(1,1,1,1);
	#endif
	/////////////////////////////////////////////////////////////////////////////////////


    float4 Color = IN.Color;
    if ( useTexture ) {
        // テクスチャ適用
        Color *= tex2D( ObjTexSampler, IN.Tex );
    }
    if ( useSphereMap ) {
        // スフィアマップ適用
        float4 TexColor = tex2D(ObjSphareSampler,IN.SpTex);
		
		float TexColorMonoCaculate = (TexColor.r+TexColor.g+TexColor.b)/3;
		float4 TexColorMono = float4(TexColorMonoCaculate,TexColorMonoCaculate,TexColorMonoCaculate,TexColor.a);
		
		TexColor = lerp(TexColorMono, TexColor, TexColor.a * Spa_CubeMap_Saturation);
		
        #if Spa_CubeMap_Use_SpecularMap == 1
        if(spadd) Color.rgb += TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
        else      Color.rgb *= TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
		
		#else
        if(spadd) Color.rgb += TexColor.rgb * Spa_CubeMap_Intensity;
        else      Color.rgb *= TexColor.rgb * Spa_CubeMap_Intensity;
		#endif
		
        Color.a *= TexColor.a;
    }
    
    if ( useToon ) {
        // トゥーン適用
        float LightNormal = dot( IN.Normal, -LightDirection );
        Color *= tex2D(ObjToonSampler, float2(0, 0.5 - LightNormal * Toon_Gradient) );
    }
    
    // スペキュラ適用
	
    #if SpecularLight_Use_SpecularMap == 1
    Color.rgb += IN.Specular * SpecularLevel * SpecularLight_Intensity;
	
	#else
    Color.rgb += IN.Specular * SpecularLight_Intensity;
	#endif
	
	#if ALPHATEST == 1
		
			if (Color.a >= AlphaThreshold)
				{
					Color.a = 1;
				}
			else
				{
					Color.a = 0;
				}
				
	#endif
    
    return Color;
}

// オブジェクト描画用テクニック（アクセサリ用）
// 不要なものは削除可
technique MainTec0 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, false);
    }
}

technique MainTec1 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, false);
    }
}

technique MainTec2 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, false);
    }
}

technique MainTec3 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, false);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, false);
    }
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTec4 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, false, true);
    }
}

technique MainTec5 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, false, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, false, true);
    }
}

technique MainTec6 < string MMDPass = "object"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(false, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(false, true, true);
    }
}

technique MainTec7 < string MMDPass = "object"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 Basic_VS(true, true, true);
        PixelShader  = compile ps_3_0 Basic_PS(true, true, true);
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// セルフシャドウ用Z値プロット

struct VS_ZValuePlot_OUTPUT {
    float4 Pos : POSITION;              // 射影変換座標
    float4 ShadowMapTex : TEXCOORD0;    // Zバッファテクスチャ
};

// 頂点シェーダ
VS_ZValuePlot_OUTPUT ZValuePlot_VS( float4 Pos : POSITION )
{
    VS_ZValuePlot_OUTPUT Out = (VS_ZValuePlot_OUTPUT)0;

    // ライトの目線によるワールドビュー射影変換をする
    Out.Pos = mul( Pos, LightWorldViewProjMatrix );

    // テクスチャ座標を頂点に合わせる
    Out.ShadowMapTex = Out.Pos;

    return Out;
}

// ピクセルシェーダ
float4 ZValuePlot_PS( float4 ShadowMapTex : TEXCOORD0 ) : COLOR
{
    // R色成分にZ値を記録する
    return float4(ShadowMapTex.z/ShadowMapTex.w,0,0,1);
}

// Z値プロット用テクニック
technique ZplotTec < string MMDPass = "zplot"; > {
    pass ZValuePlot {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_2_0 ZValuePlot_VS();
        PixelShader  = compile ps_2_0 ZValuePlot_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウON）

// シャドウバッファのサンプラ。"register(s0)"なのはMMDがs0を使っているから
sampler DefSampler : register(s0);

struct BufferShadow_OUTPUT {
    float4 Pos      : POSITION;     // 射影変換座標
    float4 ZCalcTex : TEXCOORD0;    // Z値
    float4 TexUVs   : TEXCOORD1;    // テクスチャ
    float3 Normal   : TEXCOORD2;    // 法線
    float3 Eye      : TEXCOORD3;    // カメラとの相対位置
    float2 SpTex    : TEXCOORD4;	 // スフィアマップテクスチャ座標
	float4 ScreenTex: TEXCOORD5;   // スクリーン座標
	float3 ViewVec  : TEXCOORD6;
	float4 VColor	: TEXCOORD7;
	float4 Tangent  : TEXCOORD8;
    float4 Color    : COLOR0;       // ディフューズ色
};

// 頂点シェーダ
BufferShadow_OUTPUT BufferShadow_VS(float4 Pos : POSITION, float3 Normal : NORMAL, float2 Tex : TEXCOORD0, float2 Tex2 : TEXCOORD1, float4 VColor : Vertex_Color_Stored_At , float2 SubMapUV : Sub_Map_Stored_At , float4 Tangent : Tangent_Stored_At , uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
    BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;

    // カメラ視点のワールドビュー射影変換
    Out.Pos = mul( Pos, WorldViewProjMatrix );
    
    // カメラとの相対位置
    Out.Eye = CameraPosition - mul( Pos, WorldMatrix );
    // 頂点法線
    Out.Normal = normalize( mul( Normal, (float3x3)WorldMatrix ) );
	// ライト視点によるワールドビュー射影変換
    Out.ZCalcTex = mul( Pos, LightWorldViewProjMatrix );
	
	Out.ViewVec = CameraPosition - mul(Pos, WorldMatrix);
	
	Out.VColor = VColor;
	
	Out.Tangent = Tangent;
	
	Out.TexUVs = float4(Tex,SubMapUV);
    
    // ディフューズ色＋アンビエント色 計算
    Out.Color.rgb = AmbientColor;
    if ( !useToon ) {
        Out.Color.rgb += max(0,dot( Out.Normal, -LightDirection )) * DiffuseColor.rgb;
    }
    Out.Color.a = DiffuseColor.a;
    Out.Color = saturate( Out.Color );
    
    if ( useSphereMap ) {
		if ( use_subtexture ) {
			// PMXサブテクスチャ座標
			Out.SpTex = Tex2;
	    } else {
		}
    }
	
	/////////////////////////////////////////////////////////////////////////////////////////
    // ■ ExcellentShadowシステム　ここから↓
    
    //スクリーン座標取得
    Out.ScreenTex = Out.Pos;
    
    //超遠景におけるちらつき防止
    Out.Pos.z -= max(0, (int)((CameraDistance1 - 6000) * 0.04));
    
    // ■ ExcellentShadowシステム　ここまで↑
    /////////////////////////////////////////////////////////////////////////////////////////
    
    return Out;
}

// ピクセルシェーダ
float4 BufferShadow_PS(BufferShadow_OUTPUT IN, float3 ViewVec: TEXCOORD0, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR
{
	float2 Tex = IN.TexUVs.xy;
	float2 SubMapUV = IN.TexUVs.zw;

	float4 VertexColor = float4(IN.VColor.r,IN.VColor.g,IN.VColor.b,IN.VColor.a);
	
	#ifdef SubMapTexture
	float3 SubMap = tex2D(SubMapSamp,SubMapUV);
	#endif
	
	float3 Binormal = -(cross(IN.Normal.xyz, IN.Tangent.xyz) * IN.Tangent.w);
	float3x3 TBN = transpose( float3x3(normalize(IN.Tangent.xyz), normalize(Binormal), normalize(IN.Normal)) );

	//////////////////////Normal Map related values//////////////////////////////////////
	#ifdef NormalMapTexture
		
		float4 NormalColor = tex2D( NormalMapSamp, Tex) * 2;
		
		#if TANGENT == 0
			float3 NormalDirection = normalize(IN.Normal);
			float3 V = normalize(IN.Eye);
			
			NormalColor = NormalColor.rgba;
			NormalColor.a = 1;
			float3x3 tangentFrame = compute_tangent_frame(NormalDirection, V, Tex);
			NormalDirection = normalize(mul(NormalColor - 1.0f, tangentFrame));
		
		#else
			float3 NormalDirection = normalize(mul( NormalColor - 1.0f, TBN ));
		#endif
		
	#else
		
		#if TANGENT == 0
			float3 NormalDirection = normalize(IN.Normal);
		
		#else
			float3 NormalDirection = normalize(mul( float3(0,0,1), TBN ));
		#endif
		
	#endif
	/////////////////////////////////////////////////////////////////////////////////////
	
	//////////////////////Specular Map related values//////////////////////////////////////
	#ifdef SpecularMapTexture
	float4 SpecularLevel = tex2D(SpecularMapSamp, Tex);
	
	#else
	float4 SpecularLevel = float4(1,1,1,1);
	#endif
	/////////////////////////////////////////////////////////////////////////////////////

    // スペキュラ色計算
    #if SpecularLight_Affected_By_LightDirection == 1
    float3 HalfVector = normalize( normalize(IN.Eye) + -LightDirection );
	
	#else
	float3 HalfVector = normalize( normalize(IN.Eye));
	#endif
	
    #if SpecularLight_Use_NormalMap == 1
    float3 Specular = pow( max(0,dot( HalfVector, NormalDirection )), SpecularLight_Focus ) * SpecularColor;
	
	#else
    float3 Specular = pow( max(0,dot( HalfVector, IN.Normal )), SpecularLight_Focus ) * SpecularColor;
	#endif
    
    float4 Color = IN.Color;
    float4 ShadowColor = float4(saturate(AmbientColor), Color.a);  // 影の色
    if ( useTexture ) {
        // テクスチャ適用
        float4 TexColor = tex2D( ObjTexSampler, Tex );
        // テクスチャ材質モーフ数
	    TexColor.rgb = lerp(1, TexColor * TextureMulValue + TextureAddValue, TextureMulValue.a + TextureAddValue.a);
        Color *= TexColor;
        ShadowColor *= TexColor;
    }
    if ( useSphereMap ) {
	
		// スフィアマップテクスチャ座標
		
		#if Spa_CubeMap_Use_NormalMap == 1
	    float2 NormalWV = mul( NormalDirection , (float3x3)ViewMatrix );
		
		#else
	    float2 NormalWV = mul( IN.Normal , (float3x3)ViewMatrix );
		#endif
		
	    IN.SpTex.x = NormalWV.x * 0.5f + 0.5f;
	    IN.SpTex.y = NormalWV.y * -0.5f + 0.5f;
		
        // スフィアマップ適用
        float4 TexColor = tex2D(ObjSphareSampler,IN.SpTex);
		
		float TexColorMonoCaculate = (TexColor.r+TexColor.g+TexColor.b)/3;
		float4 TexColorMono = float4(TexColorMonoCaculate,TexColorMonoCaculate,TexColorMonoCaculate,TexColor.a);
		
		TexColor = lerp(TexColorMono, TexColor, TexColor.a * Spa_CubeMap_Saturation);
		
        // スフィアテクスチャ材質モーフ数
        TexColor.rgb = lerp(spadd?0:1, TexColor * SphereMulValue + SphereAddValue, SphereMulValue.a + SphereAddValue.a);
		
        #if Spa_CubeMap_Use_SpecularMap == 1
		if(spadd) {
            Color.rgb += TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
            ShadowColor.rgb += TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
        } else {
            Color.rgb *= TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
            ShadowColor.rgb *= TexColor.rgb * SpecularLevel * Spa_CubeMap_Intensity;
        }
		
		#else
		if(spadd) {
            Color.rgb += TexColor.rgb * Spa_CubeMap_Intensity;
            ShadowColor.rgb += TexColor.rgb * Spa_CubeMap_Intensity;
        } else {
            Color.rgb *= TexColor.rgb * Spa_CubeMap_Intensity;
            ShadowColor.rgb *= TexColor.rgb * Spa_CubeMap_Intensity;
        }
		#endif
		
        Color.a *= TexColor.a;
        ShadowColor.a *= TexColor.a;
    }
    // スペキュラ適用
	
	//////////////////////////////////////////////////////////////////////////////////////
	// Cube Map Processing
	/////////////////////////////////////////////////////////////////////////////////////
	
	#ifdef CubeMapTexture
	
	#if Spa_CubeMap_Use_NormalMap == 1
	ViewVec = normalize(IN.ViewVec);
	float3 ReflVec = reflect(-ViewVec, NormalDirection);
	float4 Reflection = texCUBE(CubeMapSamp, ReflVec.xyz);
	
	float4 CubeEnv = Reflection;
	
	#else
	ViewVec = normalize(IN.ViewVec);
	float3 ReflVec = reflect(-ViewVec, IN.Normal);
	float4 Reflection = texCUBE(CubeMapSamp, ReflVec.xyz);
	
	float4 CubeEnv = Reflection;
	#endif
	
	/////////////////////////////////////////////////////////////////////////////////////
	
	float CubeEnvMonoCaculate = (CubeEnv.r+CubeEnv.g+CubeEnv.b)/3;
	float4 CubeEnvMono = float4(CubeEnvMonoCaculate,CubeEnvMonoCaculate,CubeEnvMonoCaculate,CubeEnv.a);
	
	CubeEnv = lerp(CubeEnvMono, CubeEnv, CubeEnv.a * Spa_CubeMap_Saturation);
	
	/////////////////////////////////////////////////////////////////////////////////////
	
	#if Spa_CubeMap_Use_SpecularMap == 1
	Color.rgb += CubeEnv.rgb * SpecularLevel * Spa_CubeMap_Intensity;
	ShadowColor.rgb += CubeEnv.rgb * SpecularLevel * Spa_CubeMap_Intensity;
	
	#else
	Color.rgb += CubeEnv.rgb * Spa_CubeMap_Intensity;
	ShadowColor.rgb += CubeEnv.rgb * Spa_CubeMap_Intensity;
	#endif
	
	#endif
	
	//////////////////////////////////////////////////////////////////////////////////////
    
	#if SpecularLight_Use_SpecularMap == 1
    Color.rgb += Specular * SpecularLevel * SpecularLight_Intensity;
	ShadowColor.rgb += Specular * SpecularLevel * SpecularLight_Intensity;
	
	#else
    Color.rgb += Specular * SpecularLight_Intensity;
	ShadowColor.rgb += Specular * SpecularLight_Intensity;
	#endif
    
    // テクスチャ座標に変換
    IN.ZCalcTex /= IN.ZCalcTex.w;
    float2 TransTexCoord;
    TransTexCoord.x = (1.0f + IN.ZCalcTex.x)*0.5f;
    TransTexCoord.y = (1.0f - IN.ZCalcTex.y)*0.5f;
	
	#if VERTEXCOLOR == 1
	Color *= VertexColor;
	ShadowColor *= VertexColor;
	#endif
		
	#if SUBMAP == 1
	
	#if Sub_Map_Type == 0
	Color.rgb = SubMap;
	ShadowColor.rgb = SubMap;
	
	#elif Sub_Map_Type == 1
	Color.rgb *= SubMap;
	ShadowColor.rgb *= SubMap;
	
	#elif Sub_Map_Type == 2
	Color.rgb *= (SubMap+1);
	ShadowColor.rgb *= (SubMap+1);
	
	#else
	Color.rgb *= SubMap;
	ShadowColor.rgb *= SubMap;
	Color.rgb *= (SubMap+1);
	ShadowColor.rgb *= (SubMap+1);
	#endif
	
	#endif
	
	/////////////////////////////////////////////////////////////////////////////////////////
    // ■ ExcellentShadowシステム　ここから↓
    
    #ifdef MIKUMIKUMOVING
        float4 ShadowColor = float4(saturate(AmbientColor[0].rgb), Color.a);  // 影の色
        ShadowColor.rgb *= texColor.rgb;
        if ( useSphereMap ) {
            float3 spcolor = (tex2D(ObjSphareSampler,IN.SubTex.zw).rgb * MultiplySphere.rgb + AddingSphere.rgb);
            if(spadd) ShadowColor.rgb += spcolor;
            else      ShadowColor.rgb *= spcolor;
        }
    #endif
    
    if(Exist_ExcellentShadow){
        
        IN.ScreenTex.xyz /= IN.ScreenTex.w;
        float2 TransScreenTex;
        TransScreenTex.x = (1.0f + IN.ScreenTex.x) * 0.5f;
        TransScreenTex.y = (1.0f - IN.ScreenTex.y) * 0.5f;
        TransScreenTex += ES_ViewportOffset;
        float SadowMapVal = tex2D(ScreenShadowMapProcessedSamp, TransScreenTex).r;
        
        float SSAOMapVal = 0;
        
        if(Exist_ExShadowSSAO){
            SSAOMapVal = tex2D(ExShadowSSAOMapSamp , TransScreenTex).r; //陰度取得
        }
        
        #ifdef MIKUMIKUMOVING
            float3 lightdir = LightDirection[0];
            bool toonflag = useToon && usetoontexturemap;
        #else
            float3 lightdir = LightDirection;
            bool toonflag = useToon;
        #endif
        
        if (toonflag) {
            // トゥーン適用
			#if TOONSHADING == 1
			
			#if Toon_Use_NormalMap == 1
            SadowMapVal = min(saturate(dot(NormalDirection, -lightdir) * Toon_Gradient), SadowMapVal);
			
			#else
            SadowMapVal = min(saturate(dot(IN.Normal, -lightdir) * Toon_Gradient), SadowMapVal);
			#endif
			
			#endif
            ShadowColor.rgb *= MaterialToon * Toon_Brightness;
            
            ShadowColor.rgb *= (1 - (1 - ShadowRate) * PMD_SHADOWPOWER);
        }else{
            ShadowColor.rgb *= (1 - (1 - ShadowRate) * X_SHADOWPOWER);
        }
        
        //影部分のSSAO合成
        float4 ShadowColor2 = ShadowColor;
        ShadowColor2.rgb -= ((Color.rgb - ShadowColor2.rgb) + 0.3) * SSAOMapVal * 0.2;
        ShadowColor2.rgb = max(ShadowColor2.rgb, 0);//ShadowColor.rgb * 0.5);
        
        //日向部分のSSAO合成
        Color = lerp(Color, ShadowColor, saturate(SSAOMapVal * 0.4));
        
        //最終合成
        Color = lerp(Color, ShadowColor2, (1-SadowMapVal)*Toon_Intensity);
        
		#if ALPHATEST == 1
		
			if (Color.a >= AlphaThreshold)
				{
					Color.a = 1;
				}
			else
				{
					Color.a = 0;
				}
				
		#endif
		
        #ifndef MIKUMIKUMOVING
		
        return Color;
        #endif
        
    }else
    
    // ■ ExcellentShadowシステム　ここまで↑
    /////////////////////////////////////////////////////////////////////////////////////////
    
    if( any( saturate(TransTexCoord) != TransTexCoord ) ) {
	
		#if ALPHATEST == 1
		
			if (Color.a >= AlphaThreshold)
				{
					Color.a = 1;
				}
			else
				{
					Color.a = 0;
				}
				
		#endif
	
        // シャドウバッファ外
        return Color;
    } else {
        float comp;
        if(parthf) {
            // セルフシャドウ mode2
            comp=1-saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord).r , 0.0f)*SKII2*TransTexCoord.y-0.3f);
        } else {
            // セルフシャドウ mode1
            comp=1-saturate(max(IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord).r , 0.0f)*SKII1-0.3f);
        }
        if ( useToon ) {
            // トゥーン適用
            #if TOONSHADING == 1
			
			#if Toon_Use_NormalMap == 1
            comp = min(saturate(dot(NormalDirection,-LightDirection)*Toon_Gradient),comp);
			
			#else
            comp = min(saturate(dot(IN.Normal,-LightDirection)*Toon_Gradient),comp);
			#endif
			
			#endif
            ShadowColor.rgb *= MaterialToon * Toon_Brightness;
        }
        
        float4 ans = lerp(Color, ShadowColor, (1-comp)*Toon_Intensity);
		
		#if ALPHATEST == 1
		
			if (ans.a >= AlphaThreshold)
				{
					ans.a = 1;
				}
			else
				{
					ans.a = 0;
				}
				
		#endif
		
        if( transp ) ans.a = 0.5f;
		
        return ans;
    }
}

// オブジェクト描画用テクニック（アクセサリ用）
technique MainTecBS0  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, false);
    }
}

technique MainTecBS1  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, false);
    }
}

technique MainTecBS2  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, false);
    }
}

technique MainTecBS3  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, false);
    }
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTecBS4  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, true);
    }
}

technique MainTecBS5  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, true);
    }
}

technique MainTecBS6  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, true);
    }
}

technique MainTecBS7  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, true);
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
