

#define CUSTOM_FOV 1 //Can serve as decimal FOV, the x value of the "fov" bone in the controller equal to the FOV applied to the object

	#define Custom_Fov_Model "MES40 Controller.pmd"
	#define Custom_Fov_Bone "fov"
	#define Custom_Fov_Axis 1 // 1=x | 2=y | 3=z ; Determine which direction of the bone controls the FOV value


////////////////////////////////////////////////////////////////////////////////////////////////
//
//  ExcellentShadowObject
//  作成: そぼろ
//
////////////////////////////////////////////////////////////////////////////////////////////////


#include "ExcellentShadowCommonSystem.fx"


//アクセサリに法線を使った陰影をつけるか
#define UNTOON_NORMALSHADOW 1


////////////////////////////////////////////////////////////////////////////////////////////////
// パラメータ宣言


// 座法変換行列
float4x4 WorldViewProjMatrix      : WORLDVIEWPROJECTION;
float4x4 WorldMatrix              : WORLD;
float4x4 ViewMatrix               : VIEW;
float4x4 ProjMatrix               : PROJECTION;
float4x4 LightWorldViewProjMatrix : WORLDVIEWPROJECTION < string Object = "Light"; >;

float3   LightDirection    : DIRECTION < string Object = "Light"; >;
float3   CameraPosition    : POSITION  < string Object = "Camera"; >;

// マテリアル色
float4   MaterialDiffuse   : DIFFUSE  < string Object = "Geometry"; >;
float3   MaterialAmbient   : AMBIENT  < string Object = "Geometry"; >;
float3   MaterialEmmisive  : EMISSIVE < string Object = "Geometry"; >;
float3   MaterialSpecular  : SPECULAR < string Object = "Geometry"; >;
float    SpecularPower     : SPECULARPOWER < string Object = "Geometry"; >;
float3   MaterialToon      : TOONCOLOR;
float4   EdgeColor         : EDGECOLOR;
// ライト色
float3   LightDiffuse      : DIFFUSE   < string Object = "Light"; >;
float3   LightAmbient      : AMBIENT   < string Object = "Light"; >;
float3   LightSpecular     : SPECULAR  < string Object = "Light"; >;
static float4 DiffuseColor  = MaterialDiffuse  * float4(LightDiffuse, 1.0f);
static float3 AmbientColor  = min(1, MaterialAmbient * LightAmbient + MaterialEmmisive);
static float3 SpecularColor = MaterialSpecular * LightSpecular;

bool     parthf;   // パースペクティブフラグ
bool     transp;   // 半透明フラグ
bool     spadd;    // スフィアマップ加算合成フラグ
#define SKII1    1500
#define SKII2    8000
#define Toon     3

float2 ViewportSize : VIEWPORTPIXELSIZE;
static float ViewportAspect = ViewportSize.x / ViewportSize.y;

////////////////////////////////////////////////////////////////////////////////////////////////
// FOV Injection Method

float3 Custom_Fov : CONTROLOBJECT < string name = Custom_Fov_Model ; string item = Custom_Fov_Bone ; >; 

float4x4 WorldViewProjMatrix_Final()
{
	#if CUSTOM_FOV == 0
		return WorldViewProjMatrix;
	#else
		float4x4 projMatrixFovInjected = ProjMatrix;
		
		float valueFov;
		
		#if Custom_Fov_Axis == 1
			valueFov = Custom_Fov.x;
		#elif Custom_Fov_Axis == 2
			valueFov = Custom_Fov.y;
		#else
			valueFov = Custom_Fov.z;
		#endif
		
		float tanFov = tan(valueFov * (3.14159265359 / 180) * 0.5);

		projMatrixFovInjected[0][0] = 1.0 / (tanFov * ViewportAspect);
		projMatrixFovInjected[1][1] = 1.0 / tanFov;

		return mul( mul( WorldMatrix,ViewMatrix ) , projMatrixFovInjected );
	#endif
}
////////////////////////////////////////////////////////////////////////////////////////////////

// オブジェクトのテクスチャ
texture ObjectTexture: MATERIALTEXTURE;
sampler ObjTexSampler = sampler_state {
    texture = <ObjectTexture>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = LINEAR;
    MAXANISOTROPY = 16;
};

// スフィアマップのテクスチャ
texture ObjectSphereMap: MATERIALSPHEREMAP;
sampler ObjSphareSampler = sampler_state {
    texture = <ObjectSphereMap>;
    MINFILTER = ANISOTROPIC;
    MAGFILTER = ANISOTROPIC;
    MIPFILTER = LINEAR;
    MAXANISOTROPY = 16;
};

// MMD本来のsamplerを上書きしないための記述です。削除不可。
sampler MMDSamp0 : register(s0);
sampler MMDSamp1 : register(s1);
sampler MMDSamp2 : register(s2);



////////////////////////////////////////////////////////////////////////////////////////////////

shared texture ExcellentShadowZMap : OFFSCREENRENDERTARGET;

sampler ExcellentShadowZMapSampler = sampler_state {
    texture = <ExcellentShadowZMap>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = NONE;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

shared texture ExcellentShadowZMapFar : OFFSCREENRENDERTARGET;

sampler ExcellentShadowZMapFarSampler = sampler_state {
    texture = <ExcellentShadowZMapFar>;
    MinFilter = LINEAR;
    MagFilter = LINEAR;
    MipFilter = NONE;
    AddressU  = CLAMP;
    AddressV = CLAMP;
};

////////////////////////////////////////////////////////////////////////////////////////////////
// 輪郭描画

// 頂点シェーダ
float4 ColorRender_VS(float4 Pos : POSITION) : POSITION 
{
    // カメラ視点のワールドビュー射影変換
    float4 Out = mul( Pos, WorldViewProjMatrix_Final() );
    
    return Out;
}

// ピクセルシェーダ
float4 ColorRender_PS() : COLOR
{
    // 輪郭色で塗りつぶし
    return EdgeColor;
}

// 輪郭描画用テクニック
technique EdgeTec < string MMDPass = "edge"; > {
    /*pass DrawEdge {
        AlphaBlendEnable = FALSE;
        AlphaTestEnable  = FALSE;
        
        VertexShader = compile vs_2_0 ColorRender_VS();
        PixelShader  = compile ps_2_0 ColorRender_PS();
    }*/
}


///////////////////////////////////////////////////////////////////////////////////////////////
// 影（非セルフシャドウ）描画

// 影描画用テクニック
technique ShadowTec < string MMDPass = "shadow"; > {
    
}

///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウOFF）

// オブジェクト描画用テクニック
technique MainTec0 < string MMDPass = "object";  > {
    
}

///////////////////////////////////////////////////////////////////////////////////////////////
// セルフシャドウ用Z値プロット

struct VS_ZValuePlot_OUTPUT {
    float4 Pos : POSITION;              // 射影変換座標
    float4 ShadowMapTex : TEXCOORD0;    // Zバッファテクスチャ
};

// 頂点シェーダ
VS_ZValuePlot_OUTPUT ZValuePlot_VS( float4 Pos : POSITION )
{
    VS_ZValuePlot_OUTPUT Out = (VS_ZValuePlot_OUTPUT)0;
    
    // ライトの目線によるワールドビュー射影変換をする
    Out.Pos = mul( Pos, LightWorldViewProjMatrix );
    
    // テクスチャ座標を頂点に合わせる
    Out.ShadowMapTex = Out.Pos;
    
    //Out.Pos.z *= 0.1;
    //Out.Pos.z += 0.1;
    
    return Out;
}

// ピクセルシェーダ
float4 ZValuePlot_PS( float4 ShadowMapTex : TEXCOORD0 ) : COLOR
{
    float depth = ShadowMapTex.z/ShadowMapTex.w;
    
    // R色成分にZ値を記録する
    return float4(depth, 0, 0, 1);
}

// Z値プロット用テクニック
technique ZplotTec < string MMDPass = "zplot"; > {
    pass ZValuePlot {
        AlphaBlendEnable = FALSE;
        VertexShader = compile vs_2_0 ZValuePlot_VS();
        PixelShader  = compile ps_2_0 ZValuePlot_PS();
    }
}


///////////////////////////////////////////////////////////////////////////////////////////////
// オブジェクト描画（セルフシャドウON）

// シャドウバッファのサンプラ。"register(s0)"なのはMMDがs0を使っているから
sampler DefSampler : register(s0);

struct BufferShadow_OUTPUT {
    float4 Pos       : POSITION;     // 射影変換座標
    float4 ZCalcTex  : TEXCOORD0;    // Z値
    float2 Tex       : TEXCOORD1;    // テクスチャ
    float3 Normal    : TEXCOORD2;    // 法線
    float3 Eye       : TEXCOORD3;    // カメラとの相対位置
    float4 IZCalcTex : TEXCOORD4;     // スフィアマップテクスチャ座標
    
    float4 ScreenPos : TEXCOORD5;
    
};

// 頂点シェーダ
BufferShadow_OUTPUT BufferShadow_VS(MMM_SKINNING_INPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon)
{
    BufferShadow_OUTPUT Out = (BufferShadow_OUTPUT)0;
    
    float4 pos = GETPOS;
    
    // カメラ視点のワールドビュー射影変換
    Out.Pos = mul( pos, WorldViewProjMatrix_Final() );
    
    Out.ScreenPos = Out.Pos;
    
    // カメラとの相対位置
    Out.Eye = CameraPosition - mul( pos, WorldMatrix ).rgb;
    // 頂点法線
    Out.Normal = normalize( mul( IN.Normal, (float3x3)WorldMatrix ) );
    
    // ライト視点によるワールドビュー射影変換
    Out.ZCalcTex = mul( pos, LightWorldViewProjMatrix );
    Out.IZCalcTex = mul( pos, InternalLightWorldViewProjMatrix );
    
    // テクスチャ座標
    Out.Tex = IN.Tex;
    
    return Out;
}


// ピクセルシェーダ
float4 BufferShadow_PS(BufferShadow_OUTPUT IN, uniform bool useTexture, uniform bool useSphereMap, uniform bool useToon) : COLOR
{
    // スペキュラ色計算
    float3 HalfVector = normalize( normalize(IN.Eye) + -LightDirection );
    float3 Specular = pow( max(0,dot( HalfVector, normalize(IN.Normal) )), SpecularPower ) * SpecularColor;
    
    float4 Color = float4(1,1,1,1);
    
    float Alpha = DiffuseColor.a;
    float ShadowRate = 1;
    float ShadowBlurStrength = 0;
    
    float Z1;
    
    //Z1 = IN.ScreenPos.w;
    Z1 = 1.0 / (1.0 - IN.ScreenPos.z / IN.ScreenPos.w);
    //Z1 = IN.ScreenPos.z / IN.ScreenPos.w;
    
    if ( useTexture ) {
        // テクスチャ適用
        float4 TexColor = tex2D( ObjTexSampler, IN.Tex );
        Alpha *= TexColor.a;
    }
    
    
    
    ///////////////////////////////////////////////////////////////////////
    //シャドウシステム
    
    // テクスチャ座標に変換
    IN.IZCalcTex.xyz /= IN.IZCalcTex.w;
    float2 TransTexCoord1 = 0.5 + IN.IZCalcTex.xy * float2(0.5, -0.5);
    float2 TransTexCoord2 = 0.5 + (IN.IZCalcTex.xy / SIZERATE_FAR) * float2(0.5, -0.5);
    
    float farfade = saturate(5 * (1 - length(IN.IZCalcTex.xy / SIZERATE_FAR)));
    
    if(!any( saturate(TransTexCoord2) != TransTexCoord2 ) ) { 
        float comp;
        
        float mixrate = saturate((length(IN.IZCalcTex.xy) - 0.8) / (1 - 0.8));
        
        float depth1 = tex2D(ExcellentShadowZMapSampler,TransTexCoord1).r;
        float depth2 = tex2D(ExcellentShadowZMapFarSampler,TransTexCoord2).r;
        
        float depth = lerp(depth1, depth2, mixrate);
        
        #if MULTISAMPLING==1
        float step = 1.0 / SHADOWBUFSIZE;
        
        float depth1a = tex2D(ExcellentShadowZMapSampler,TransTexCoord1 + float2(step, 0)).r;
        float depth1b = tex2D(ExcellentShadowZMapSampler,TransTexCoord1 + float2(-step, 0)).r;
        float depth1c = tex2D(ExcellentShadowZMapSampler,TransTexCoord1 + float2(0, step)).r;
        float depth1d = tex2D(ExcellentShadowZMapSampler,TransTexCoord1 + float2(0, -step)).r;
        
        float depth_a = lerp(depth1a, depth2, mixrate);
        float depth_b = lerp(depth1b, depth2, mixrate);
        float depth_c = lerp(depth1c, depth2, mixrate);
        float depth_d = lerp(depth1d, depth2, mixrate);
        
        #endif
        
        float dist = IN.IZCalcTex.z - depth;
        
        float sdrate = 30000 * size1 / (1 + mixrate * 3) - 0.05 * sqrt(size1);
        //comp = 1 - saturate(max(dist, 0.0f) * 20000 / (1 + mixrate * 3) - 0.05);
        comp = 1 - saturate(max(dist, 0.0f) * sdrate);
        
        #if MULTISAMPLING==1
        float compa, compb, compc, compd;
        compa = 1 - saturate(max(IN.IZCalcTex.z - depth_a, 0.0f) * sdrate);
        compb = 1 - saturate(max(IN.IZCalcTex.z - depth_b, 0.0f) * sdrate);
        compc = 1 - saturate(max(IN.IZCalcTex.z - depth_c, 0.0f) * sdrate);
        compd = 1 - saturate(max(IN.IZCalcTex.z - depth_d, 0.0f) * sdrate);
        comp = (comp + compa + compb + compc + compd) / 5;
        #endif
        
        comp = lerp(1, comp, farfade);
        
        ShadowBlurStrength = max(0, dist) * 300 / sqrt(size1);
        ShadowRate = comp;
    }
    
    
    #ifndef MIKUMIKUMOVING
    #if MMDSHADOW_USING>0
    
    // テクスチャ座標に変換
    IN.ZCalcTex /= IN.ZCalcTex.w;
    float2 TransTexCoord0;
    TransTexCoord0.x = (1.0f + IN.ZCalcTex.x)*0.5f;
    TransTexCoord0.y = (1.0f - IN.ZCalcTex.y)*0.5f;
    
    if( !any( saturate(TransTexCoord0) != TransTexCoord0 ) && IN.ZCalcTex.z <= 1) {
        
        float comp;
        
        float dist = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0).r;
        
        #if MULTISAMPLING==1
        float step = 1.0 / 3000;
        float dist_a = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0 + float2(step, 0)).r;
        float dist_b = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0 + float2(-step, 0)).r;
        float dist_c = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0 + float2(0, step)).r;
        float dist_d = IN.ZCalcTex.z-tex2D(DefSampler,TransTexCoord0 + float2(0, -step)).r;
        
        #endif
        
        float sdrate;
        
        if(parthf) {
            // セルフシャドウ mode2
            sdrate = SKII2 * TransTexCoord0.y - 0.3f;
        } else {
            // セルフシャドウ mode1
            sdrate = SKII1 - 0.3f;
        }
        
        comp = 1 - saturate(max(dist , 0.0f) * sdrate);
        
        #if MULTISAMPLING==1
        float compa, compb, compc, compd;
        compa = 1 - saturate(max(dist_a , 0.0f) * sdrate);
        compb = 1 - saturate(max(dist_b , 0.0f) * sdrate);
        compc = 1 - saturate(max(dist_c , 0.0f) * sdrate);
        compd = 1 - saturate(max(dist_d , 0.0f) * sdrate);
        comp = (comp + compa + compb + compc + compd) / 5;
        #endif
        
        float mixrate = saturate(4 * (1 - length(IN.ZCalcTex.xy)));
        
        float mix1 = lerp(ShadowRate, comp, mixrate);
        float mix2 = min(ShadowRate, lerp(1, comp, mixrate));
        
        comp = lerp(mix1, mix2, saturate(ShadowBlurStrength * 8));
        
        float vecrate = saturate(dot(normalize(IN.Eye), IN.Normal) * 1.7);
        vecrate = pow(vecrate, 0.7);
        ShadowRate = lerp(ShadowRate, comp, vecrate);
        //ShadowRate = comp;
        
    }
    
    #endif
    #endif
    
    if ( useToon ) ShadowRate = min(ShadowRate, saturate(dot(IN.Normal,-LightDirection)*Toon));
    #if UNTOON_NORMALSHADOW==1
    //else           ShadowRate = min(ShadowRate, saturate(dot(IN.Normal,-LightDirection)*Toon));
    #endif
    
    
    Color.r = ShadowRate;
    Color.g = Z1;
    Color.b = ShadowBlurStrength;
    Color.a = Alpha;
    
    Color.a *= (Alpha > ShadowAlphaThreshold);
    
    //Color = float4(0.5,0,0,1);
    
    return Color;
}


// オブジェクト描画用テクニック（アクセサリ用）
technique MainTecBS0  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, false);
    }
}

technique MainTecBS1  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, false);
    }
}

technique MainTecBS2  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, false);
    }
}

technique MainTecBS3  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = false; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, false);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, false);
    }
}

// オブジェクト描画用テクニック（PMDモデル用）
technique MainTecBS4  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, false, true);
    }
}

technique MainTecBS5  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = false; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, false, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, false, true);
    }
}

technique MainTecBS6  < string MMDPass = "object_ss"; bool UseTexture = false; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(false, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(false, true, true);
    }
}

technique MainTecBS7  < string MMDPass = "object_ss"; bool UseTexture = true; bool UseSphereMap = true; bool UseToon = true; > {
    pass DrawObject {
        VertexShader = compile vs_3_0 BufferShadow_VS(true, true, true);
        PixelShader  = compile ps_3_0 BufferShadow_PS(true, true, true);
    }
}

///////////////////////////////////////////////////////////////////////////////////////////////
